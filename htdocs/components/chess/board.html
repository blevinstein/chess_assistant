<link rel="import" href="/bower_components/polymer/polymer.html">
<link rel="import" href="/bower_components/core-ajax/core-xhr.html">

<polymer-element name="chess-board">
  <template>
    <style>
      table {
        border: 5px solid black;
        border-spacing: 0;
      }
      tr {
        height: 100px;
      }
      td {
        text-align: center;
        font-size: 60px;
        width: 100px;
      }
      .threatCount {
        font: bold 12px sans-serif;
      }
      .bubble {
        background-color: white;
        border: 1px solid;
        border-radius: 10px;
        display: inline-block;
        line-height: 16px;
        height: 16px;
        width: 16px;
      }
    </style>
    <core-xhr id="xhr"></core-xhr>
    <table>
      <template repeat="{{ rank in range(N) }}">
        <tr>
          <template repeat="{{ file in range(N) }}">
            <td style="background-color:{{ getColor(file, rank) }}"
                rank="{{rank}}"
                file="{{file}}"
                on-click="{{handleClick}}">
              <template bind="{{positionRef(position, [file, rank]) as data}}">
                <template if="{{data}}">
                  {{data.repr}}
                  <div class="threatCount"
                      style="{{ threatStyle(data.threatCount) }}">
                    <div class="bubble">
                      {{data.threatCount}}
                    </div>
                  </div>
                </template>
              </template>
            </td>
          </template>
        </tr>
      </template>
    </table>
  </template>
  <script>

    // convenience function: equality for locations
    window.eq = function(loc1, loc2) {
      return loc1[0] == loc2[0] && loc1[1] == loc2[1];
    };

    // convenience function: array contains for locations
    window.cont = function(arr, loc) {
      for (var i = 0; i < arr.length; i++) {
        if (eq(arr[i], loc)) { return true; }
      }
      return false;
    },

    // utility to create callbacks
    window.cb = function(self, handler) {
      return function (resp) {
        self.errorCheck(resp);
        handler.call(self, resp);
      };
    },

    Polymer({
      lit: [ ],
      position: [ ],
      N: 8,
      lastClick: null,

      getColor: function (file, rank) {
        if (cont(this.lit, [file, rank])) { return "#0f0"; }
        // else return black/white checkerboard
        if ((file + rank) % 2 == 0) {
          return "#aaa";
        } else {
          return "#666";
        }
      },

      threatStyle: function (threatCount) {
        if (threatCount > 0) {
          return "color: green";
        } else if (threatCount < 0) {
          return "color: red";
        } else {
          return "color: #f90";
        }
      },

      setPosition: function(newPosition) {
        // TODO re-examine how this updates, try to trigger refresh
        this.position = newPosition;
      },
      setPositionCallback: function(resp) {
        this.setPosition(JSON.parse(resp));
      },

      positionRef: function(position, loc) {
        return position.filter(function (elem) {
            return eq(elem.loc, loc);
        })[0];
      },

      range: function (n) {
        var arr = [];
        for (var i = 0; i < n; i++) {
          arr.push(i);
        }
        return arr;
      },

      ready: function () {
        var self = this;

        // get a new board
        this.$.xhr.request({url: "/new-board", callback: cb(this, this.setPositionCallback)});
      },

      makeMove: function (source, dest) {
        var self = this;

        var params = {
          position: this.position,
          source: source,
          dest: dest
        };

        this.$.xhr.request({
          body: JSON.stringify(params),
          callback: cb(this, this.setPositionCallback),
          method: "post",
          url: "/try-move"});
      },

      refresh: function () {
        var self = this;
        // HACK changes N to force update
        self.N = 0;
        setTimeout(function () { self.N = 8; }, 1);
      },

      handleClick: function(e) {
        if (e.toElement.tagName != "TD") {
          this.lastClick = null;
          return;
        }

        // get click location
        var click = [parseInt(e.toElement.getAttribute("file")),
            parseInt(e.toElement.getAttribute("rank"))];

        // if we have 2 locations, try to make a move
        // TODO replace with is-valid check
        if (this.lastClick != null && cont(this.lit, click)) {
          this.makeMove(this.lastClick, click);
          this.lastClick = null;
          this.unlight();
        } else { // else get possible moves from here
          this.getMoves(click);
          this.lastClick = click;
        }
      },

      // checks for exception dumps in server responses
      errorCheck: function(resp) {
        if (resp[0] == "#") { throw resp; }
      },

      light: function (locations) {
        this.lit = locations;
        this.refresh();
      },
      unlight: function () {
        this.light([]);
      },

      lightDestinations: function(moves) {
        this.light(moves.map(function (move) { return move[1]; }));
      },
      lightDestinationsCallback: function(resp) {
        this.lightDestinations(JSON.parse(resp));
      },

      getMoves: function(loc) {
        var self = this;

        var params = {
          loc: loc,
          position: this.position
        };

        if (this.positionRef(this.position, params.loc) == null) {
          return; // square is empty
        }

        this.$.xhr.request({
          body: JSON.stringify(params),
          callback: cb(this, this.lightDestinationsCallback),
          method: "post",
          url: "/moves"});
      },
    });
  </script>
</polymer-element>
