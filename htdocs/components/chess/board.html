<link rel="import" href="/bower_components/polymer/polymer.html">
<link rel="import" href="/bower_components/core-ajax/core-xhr.html">
<link rel="import" href="/bower_components/core-icons/core-icons.html">

<polymer-element name="chess-board">
  <template>
    <style>
      svg {
        border: 5px solid black;
      }
      svg text {
        text-anchor: middle;
        alignment-baseline: central;
        pointer-events: none;
        font-family: sans-serif;
      }
      svg g.square:hover text.piece {
        fill: yellow;
      }
    </style>
    <core-xhr id="xhr"></core-xhr>
    <svg width="{{8 * D + 50}}" height="{{8 * D + 50}}">
      <template repeat="{{i in range(N) }}">
        <!-- file labels -->
        <text x="{{(i + 0.5) * D + 50}}" y="25" font-size="{{D * 0.25}}">
          {{fileStr(i)}}
        </text>
        <!-- rank labels -->
        <text x="25" y="{{(7 - i + 0.5) * D + 50}}" font-size="{{D * 0.25}}">
          {{rankStr(i)}}
        </text>
      </template>
      <g transform="translate(50, 50)">
        <template repeat="{{ file in range(N) }}">
          <template repeat="{{ rank in range(N) }}">
            <g transform="translate({{file * D}}, {{(N-1 - rank) * D}})" class="square">
              <!-- background -->
              <rect width="{{D}}"
                    height="{{D}}"
                    fill="{{grid[file][rank].background}}"
                    on-click="{{handleClick}}"
                    data-clickable="true"
                    data-file="{{file}}"
                    data-rank="{{rank}}" />
              <template bind="{{grid[file][rank] as data}}">
                <template if="{{data}}">
                  <!-- piece -->
                  <text x="{{0.5 * D}}"
                        y="{{0.5 * D}}"
                        class="piece"
                        font-size="{{D * 0.5}}">
                    {{data.repr}}
                  </text>
                  <!-- threat count -->
                  <template if="{{data.piece}}">
                    <g transform="translate({{0.8 * D}}, {{0.8 * D}})">
                      <circle r="10" fill="{{threatColor(data.threatCount)}}" />
                      <text fill="white">
                        {{data.threatCount}}
                      </text>
                    </g>
                  </template>
                  <!-- flags -->
                  <template if="{{data.overloadedDefender}}">
                    <g transform="translate({{0.2 * D}}, {{0.2 * D}})">
                      <title>Overloaded Defender</title>
                      <circle r="10" fill="white" />
                      <text fill="red">!</text>
                    </g>
                  </template>
                </template>
              </template>
            </g>
          </template>
        </template>
      </g>
    </svg>
  </template>
  <script>

    // convenience function: equality for locations
    window.eq = function(loc1, loc2) {
      return loc1[0] == loc2[0] && loc1[1] == loc2[1];
    };

    // convenience function: array contains for locations
    window.cont = function(arr, loc) {
      for (var i = 0; i < arr.length; i++) {
        if (eq(arr[i], loc)) { return true; }
      }
      return false;
    },

    // utility to create callbacks
    window.cb = function(self, handler) {
      return function (resp) {
        self.errorCheck(resp);
        handler.call(self, resp);
      };
    },

    Polymer({
      lit: [],
      grid: [],
      position: [],
      N: 8,
      D: 100, // width of square
      lastClick: null,

      getBackground: function (file, rank) {
        if (cont(this.lit, [file, rank])) { return "#0f0"; }
        // else return black/white checkerboard
        if ((file + rank) % 2 == 0) {
          return "#666";
        } else {
          return "#aaa";
        }
      },

      fileStr: function (file) {
        return String.fromCharCode('a'.charCodeAt(0) + file);
      },

      rankStr: function (rank) {
        return String.fromCharCode('1'.charCodeAt(0) + rank);
      },

      threatColor: function (threatCount) {
        if (threatCount > 0) {
          return "green";
        } else if (threatCount < 0) {
          return "red";
        } else {
          return "#f90";
        }
      },

      setPosition: function(newPosition) {
        this.grid = [];
        for (var i = 0; i < this.N; i++) {
          this.grid[i] = [];
          for (var j = 0; j < this.N; j++) {
            this.grid[i][j] = this.positionRef(newPosition, [i, j]) || [];
          }
        }
        this.position = newPosition;
        this.refresh();
      },
      setPositionCallback: function(resp) {
        this.setPosition(JSON.parse(resp));
      },

      positionRef: function(position, loc) {
        return position.filter(function (elem) {
            return eq(elem.loc, loc);
        })[0];
      },

      range: function (n) {
        var arr = [];
        for (var i = 0; i < n; i++) {
          arr.push(i);
        }
        return arr;
      },

      ready: function () {
        var self = this;

        // get a new board
        this.$.xhr.request({url: "/new-board", callback: cb(this, this.setPositionCallback)});
      },

      makeMove: function (source, dest) {
        var self = this;

        var params = {
          position: this.position,
          source: source,
          dest: dest
        };

        this.$.xhr.request({
          body: JSON.stringify(params),
          callback: cb(this, this.setPositionCallback),
          method: "post",
          url: "/try-move"});
      },

      refresh: function () {
        for (var i = 0; i < this.N; i++) {
          for (var j = 0; j < this.N; j++) {
            this.grid[i][j] = this.grid[i][j] || [];
            this.grid[i][j].background = this.getBackground(i, j);
          }
        }
      },

      handleClick: function(e, detail, sender) {
        if (sender.dataset.clickable != "true") {
          this.lastClick = null;
          return;
        }

        // get click location
        var click = [parseInt(sender.dataset.file), parseInt(sender.dataset.rank)];

        // if we have 2 locations, try to make a move
        // TODO replace with is-valid check
        if (this.lastClick != null && cont(this.lit, click)) {
          this.makeMove(this.lastClick, click);
          this.lastClick = null;
          this.unlight();
        } else { // else get possible moves from here
          this.getMoves(click);
          this.lastClick = click;
        }
      },

      // checks for exception dumps in server responses
      errorCheck: function(resp) {
        if (resp[0] == "#") { throw resp; }
      },

      light: function (locations) {
        this.lit = locations;
        this.refresh();
      },
      unlight: function () {
        this.light([]);
      },

      lightDestinations: function(moves) {
        this.light(moves.map(function (move) { return move[1]; }));
      },
      lightDestinationsCallback: function(resp) {
        this.lightDestinations(JSON.parse(resp));
      },

      getMoves: function(loc) {
        var self = this;

        var params = {
          loc: loc,
          position: this.position
        };

        if (this.grid[loc[0]][loc[1]].piece == null) {
          this.lightDestinations([]);
          return;
        }

        this.$.xhr.request({
          body: JSON.stringify(params),
          callback: cb(this, this.lightDestinationsCallback),
          method: "post",
          url: "/moves"});
      },
    });
  </script>
</polymer-element>
